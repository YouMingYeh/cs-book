## Computer Language

When designing a product, defining its specifications is crucial. This principle applies to computer hardware and software as well. The **Instruction Set Architecture (ISA)** serves as the specification for a computer's software interface. To understand how a computer is built and operates, we need to grasp the instructions that drive it. In this section, we will explore the **MIPS assembly language** and how to map high-level programming concepts to low-level machine instructions.

### Basic Concepts

Commands in high-level programming languages, such as C, Java, or Python, are called **statements**. These statements are mapped to **instructions** in assembly language. For example, the C statement `p = x + y * z` can be translated into MIPS assembly as a series of instructions like `add $s0, $s1, $s2`. Typically, a single high-level statement translates into multiple low-level instructions.

An **instruction** is a **primitive operation** that the CPU executes. The collection of instructions that a CPU can execute is known as its **Instruction Set**. CPUs are compatible if they use the same instruction set.

In low-level programming, data is stored in hardware, so understanding the fundamental hardware structure and the instruction set, which forms the ISA (Instruction Set Architecture), is essential.

### MIPS Assembly Language

**MIPS** is a family of processors, including models like the MIPS R2000/R3000 (32-bit), MIPS R4000 (64-bit), and MIPS R8000 (for graphics or scientific applications). Here, we introduce the MIPS R2000 instruction set.

The amount of data that a CPU can process in a single instruction is called the **word size**. The MIPS R2000 has a word size of **32 bits**, meaning it can process 32 bits of data in a single instruction.

Instruction sets are divided into two categories: **RISC** (Reduced Instruction Set Computer) and **CISC** (Complex Instruction Set Computer). **MIPS is a RISC architecture**, meaning it has a small number of simple instructions, making it faster to execute instructions. In contrast, **CISC architectures** have a large number of complex instructions, offering more functionality but potentially increasing the complexity for programmers.

<details>
<summary>
ü§î Prior to the early 1980s, machines were built with more and more complex instruction sets. Why has there been a move to RISC machines away from complex instruction machines?
</summary>

**Answer**:
The move to **RISC (Reduced Instruction Set Computer)** architectures from complex instruction set computers (CISC) was driven by:

1. **Simplicity and Speed**: RISC uses a small set of simple instructions, enabling faster execution.
2. **Efficient Pipelining**: RISC designs facilitate pipelining, allowing multiple instructions to be processed simultaneously.
3. **Lower Cost and Power Consumption**: Simpler designs reduce manufacturing costs and power usage.
4. **Compiler Optimization**: Modern compilers efficiently translate high-level code into RISC instructions.
5. **Predictable Performance**: Uniform instruction length and simple addressing modes in RISC lead to more consistent and optimized performance.

These advantages made RISC architectures more efficient, cost-effective, and easier to implement, driving the shift away from CISC architectures.

Sources:
- [RISC vs CISC](https://www.educba.com/risc-vs-cisc/)
- [How RISC and CISC Processors Work](https://www.howtogeek.com/194869/how-risc-and-cisc-processors-work/)
</details>

### Stored Program Concept (Von Neumann Machine)

Modern computers are built on two fundamental principles: **instructions are represented as binary numbers**, and **programs must be loaded into memory before execution**. This concept is known as the **stored program concept** or the **Von Neumann Machine**. This allows instruction sets to be distributed in binary form, enabling compatibility across various computers that share the same instruction set architecture.

### Instructions Structure
We should understand hardware information:
- **Memory**: Data and instructions are stored in memory.
- **Registers**: Temporary storage locations in the CPU.
- **Instruction Format**: How instructions are structured.
- **Addressing Mode**: How to access data in memory.

#### Basic Computer Structure

A basic computer structure comprises the control unit, datapath, memory, and I/O devices. The control unit and datapath together form the processor. Registers are stored in the datapath of the processor. Data is loaded from memory into the registers, operations are performed, and the results are stored back into memory.

![Basic Computer Structure](https://upload.wikimedia.org/wikipedia/commons/0/08/Computer_architecture_block_diagram.png)

The **Control Unit** directs the operation of the processor, while the **Datapath** performs arithmetic and logic operations via the **ALU (Arithmetic Logic Unit)** and stores intermediate data in **Registers**. **Memory** holds the program, data, and instructions. **I/O Devices** manage input, output, and storage.


<details>
<summary>
üóíÔ∏èCheat Sheet
</summary>

CPU = Control Unit + Datapath = Control Unit + (ALU + Registers)
Program in Memory = Data + Instructions
I/O Devices = Input + Output + Storage

</details>

#### Memory

Memory is a large array of **bytes**, each with a unique **address**, making it **byte addressable** (starting from 0). In practice, most data is stored in **words** (4 bytes), and the address points to the first byte of the word, making it **word addressable**.

For example:
- Address `0x0000` points to the first byte of the first word.
- Address `0x0004` points to the first byte of the second word.

If we use 32 bits to represent memory addresses, we can address up to \(2^{32}\) bytes of memory, which equals 4GB of memory.

In MIPS architecture, all byte addresses must be **word-aligned**, meaning the address must be a multiple of 4. This ensures that the CPU can access memory efficiently for each instruction.

Here is an illustration of byte and word addresses in memory:

| Address (Hex) | Byte 1 | Byte 2 | Byte 3 | Byte 4 |
|---------------|--------|--------|--------|--------|
| 0x0000        | 0x01   | 0x02   | 0x03   | 0x04   |
| 0x0004        | 0x05   | 0x06   | 0x07   | 0x08   |
| 0x0008        | 0x09   | 0x0A   | 0x0B   | 0x0C   |

In this example:
- Address `0x0000`, `0x0004`, and `0x0008` point to the first byte of each word and are **word-aligned**.

<details>
<summary>
üóíÔ∏èCheat Sheet
</summary>

- **Byte Addressable**: Each byte has a unique address.
- **Word Addressable**: Each address points to a word (4 bytes).
- **Word-Aligned**: Addresses must be multiples of 4 in MIPS.

</details>

#### Byte-Order or Endianness

**Endianness** refers to the order in which bytes are stored in memory. There are two types of endianness:

1. **Big-Endian**: The most significant byte (MSB) is stored at the lowest memory address. MIPS uses big-endian format.
2. **Little-Endian**: The least significant byte (LSB) is stored at the lowest memory address.

![Big-Endian vs Little-Endian](https://yoginsavani.com/wp-content/uploads/2023/05/Big-endian-and-Little-endian-1024x576.png)


**Quick Quiz**:
| a. | 0x12345678 |
|----|------------|
| b. | 0xbeadf00d |

<details>
<summary>
ü§î Show how the data in the table above would be arranged in memory of little endian and big endian machine. Assume the data is stored starting at address 0.
</summary>

**Answer**:

1. For 0x12345678

| Address | Big-Endian | Little-Endian |
|---------|------------|---------------|
| 0       | 12         | 78            |
| 1       | 34         | 56            |
| 2       | 56         | 34            |
| 3       | 78         | 12            |

2. For 0xbeadf00d

| Address | Big-Endian | Little-Endian |
|---------|------------|---------------|
| 0       | be         | 0d            |
| 1       | ad         | f0            |
| 2       | f0         | ad            |
| 3       | 0d         | be            |

</details>

<details>
<summary>
ü§î If a decimal number 1,000,000 (000F4240<sub>16</sub>) is to be stored starting from address 80, consider using 1. Big-Endian 2. Little-Endian. What is the content of memory at that address?
</summary>

**Answer**:

1. Big-Endian

| Address | Content |
|---------|---------|
| 80      | 00      |
| 81      | 0F      |
| 82      | 42      |
| 83      | 40      |

2. Little-Endian

| Address | Content |
|---------|---------|
| 80      | 40      |
| 81      | 42      |
| 82      | 0F      |
| 83      | 00      |

</details>

#### Registers
**Registers** are small, fast storage locations within the CPU that temporarily hold data such as operands, addresses, and results. Due to their limited number, registers offer quicker access than main memory (4 bytes per register). MIPS architecture features **32 general-purpose 32-bit registers** and **32 floating-point registers** ($f0, $f1, ..., $f31). Additionally, it includes special-purpose registers like the **Program Counter (PC)**, **Stack Pointer (SP)**, and **Return Address (RA)**.

Two 32-bit numbers can be multiplied into a 64-bit number. MIPS uses **Hi** and **Lo** special registers to store the high and low bits of the result, or the remainder and quotient of a division operation. For example, after a multiplication operation, the **Hi register** stores the upper 32 bits, while the **Lo register** stores the lower 32 bits.

| Operation      | Hi Register | Lo Register |
|----------------|-------------|-------------|
| Multiplication | **Upper 32 bits of result** | **Lower 32 bits of result** |
| Division       | **Remainder**   | **Quotient**    |

The **Program Counter (PC)** is a 32-bit special register that holds the address of the next instruction to be executed, automatically incrementing after each instruction is fetched.

Most programs use more variables than there are registers available. Therefore, compilers store the most frequently used variables in registers and keep the rest in memory, using load and store instructions to transfer data between memory and registers. **Spilling registers** involves moving data from registers to memory to free up registers for other variables.
![Registers](https://lh3.googleusercontent.com/proxy/OrQ2VaI5DxcGn9kyXWBWNvVcTtOHncIU4EloLd2F5W20k_hKVwDRBkUwLsKXV7sZ1PASV2ej3LYDOkw1xHAnlO4e75X1LliCuf9gnbEU8zBRyes)

- **Coprocessor 0 (CP0)**: **Handles exceptions**, controls the MMU (Memory Management Unit), and manages the TLB (Translation Lookaside Buffer).
- **Coprocessor 1 (CP1)**: **Floating Point Unit (FPU)**, Handles floating-point operations.

<details>
<summary>
ü§î Why not more registers?
</summary>

**Answer**:
1. **Decoding Complexity**: Accessing a large number of registers can slow down the decoding process, making the CPU clock cycle longer and reducing overall speed.
2. **Power Consumption**: More registers consume more power, which can lead to higher energy consumption and heat generation.
</details>

#### General Purpose Registers (GPRs)

| Type                 | Name | Number  | Usage                                          |
|----------------------|------|---------|------------------------------------------------|
| **Assembler**         | \$at    | \$1      | Assembler temporary, reserved for assembler    |
| **OS-related**        | \$k0-\$k1 | \$26-\$27 | Reserved for OS                                |
| **OS-related**        | \$v0-\$v1 | \$2-\$3   | Values for results                             |
| **Memory Management** | \$fp    | \$30     | Frame pointer                                  |
| **Memory Management** | \$sp    | \$29     | Stack pointer                                  |
| **Memory Management** | \$gp    | \$28     | Global pointer                                 |
| **Return Address**    | \$ra    | \$31     | Return address for function calls              |
| **Procedure Call**    | \$a0-\$a3 | \$4-\$7   | Function arguments                             |
| **More Temporaries**  | \$t8-\$t9 | \$24-\$25 | More temporary storage                         |
| **Saved Temporaries** | \$s0-\$s7 | \$16-\$23 | Saved temporary, preserved across calls        |
| **Temporary**        | \$t0-\$t7 | \$8-\$15  | Temporary storage, not preserved across calls  |
| **Variables/constants** | \$zero | \$0      | Constant value 0, read-only                    |

<details>
<summary>
üîç Deep Dive: Usage of Registers
</summary>

- **\$a0 - \$a3 (Arguments)**: Used to pass arguments to functions during system calls.
- **\$ra (Return Address)**: Stores the return address for function calls.
- **\$gp (Global Pointer)**: Points to the first variable address in the static data segment in memory.
- **\$sp (Stack Pointer)**: Points to the top of the stack.
- **\$fp (Frame Pointer)**: Points to the bottom of the stack frame (activation record or procedure frame).
- **\$s0 - \$s7 (Saved Temporaries)**: Stores frequently used variables, preserved across function calls.
- **\$t0 - \$t9 (Temporaries)**: Temporary storage for arithmetic operations, not preserved across function calls.
- **\$zero (Zero)**: Constant value 0, read-only, hardwired to zero.

When initializing variables in high-level languages, the compiler creates a symbol table to map variables to registers and provides this to the OS before runtime.

</details>

#### Memory Management and Related Registers

A program in memory is divided into five address segments (from high to low addresses):

1. **Stack**: Contains local variables, function arguments, and return addresses. Grows from high to low addresses.
2. **Heap**: Used for dynamically allocated memory, like pointers. Grows from low to high addresses.
3. **Static Data**: Stores global variables that do not change during program execution.
4. **Text (or Code)**: Contains the program instructions.
![Memory Segments](https://upload.wikimedia.org/wikipedia/commons/6/61/Mips_memory.jpg)

**Procedure Frame (Activation Record)**:
Each function call creates a new frame on the stack, storing the return address, arguments, local variables, and saved registers. The frame pointer (\$fp) points to the base of the current frame, while the stack pointer (\$sp) points to the top of the stack.

- **Global Pointer (\$gp)**: Points to the first variable address in the static data segment.
- **Stack Pointer (\$sp)**: Points to the top of the stack.
- **Frame Pointer (\$fp)**: Points to the base of the current procedure frame.

![Stack](/co/procedure-frame.png)

#### Translation and Execution of Programs

Computer hardware is designed to execute machine code, a sequence of binary instructions. High-level languages like C, Java, or Python are translated into machine code to be executed by the CPU. This translation process involves several steps, including compilation, assembly, linking, and loading.

#### Steps
High-level languages are translated into machine code through a series of steps:

1. **High-Level Language (e.g., C, Java) Program -> Compiler -> Assembly Language Program**: The source code is converted into assembly language.
2. **Assembly Language Program -> Assembler -> Object Code**: The assembly code is translated into machine code, also known as object code.
3. **Object Code -> Linker -> Executable Code**: The linker combines object code with required libraries and resolves address references to produce an executable file.
4. **Executable Code -> Loader -> Memory -> Execution**: The loader loads the executable code into memory, preparing it for execution by the CPU.

Example:
Imagine you wrote a C program that adds two numbers. The compiler translates the C code into assembly language. The assembler converts this assembly language into object code. The linker combines this object code with necessary libraries (like `printf`) and resolves address references to produce the final executable. The loader then loads this executable into memory, where it can be executed by the CPU.

In some systems, these steps are optimized for speed. For instance, some systems produce pre-linked modules, or use a linking loader to combine linking and loading steps.

### Program Translation and Execution
| Step | Description |
|------|-------------|
| **Compiler** | Converts high-level language (C, Java) into assembly language. |
| **Assembler** | Translates assembly language into object code (machine code). |
| **Linker** | Combines object code with libraries and resolves address references to create executable code. |
| **Loader** | Loads executable code into memory for execution by the CPU. |


<details>
<summary>
üîç Deep dive: File extensions
</summary>
UNIX:
- `.c` for C source code
- `.s` for assembly code
- `.o` for object code
- `.a` for static libraries
- `.so` for dynamic libraries
- `.out` for executables (default output for the `ld` linker)

MS-DOS:
- `.c` for C source code
- `.asm` for assembly code
- `.obj` for object code
- `.exe` for executables
- `.lib` for static libraries
- `.dll` for dynamic libraries
</details>

![Translation Hierarchy](https://image1.slideserve.com/3263004/program-translation-hierarchy-l.jpg)

#### Loader

1. **Read Executable Header**: Determine the size of the text and data segments.
2. **Allocate Memory**: Allocate a large enough contiguous block of memory.
3. **Copy Instructions and Data**: Transfer executable instructions and data into memory.
4. **Copy Arguments**: Place program arguments into the stack.
5. **Initialize Registers**: Set up registers, with the stack pointer set to the available address.
6. **Jump to Start-Up Routine**: Transfer control to the start-up routine, which copies arguments from the stack to argument registers and then jumps to the main program. After the main program finishes, control returns to the start-up routine, which calls the exit system call.

All programs run as OS subroutines, ensuring system security by maintaining OS control.

![Program Translation](/co/program-translation.png)

#### Assembler Components
After reviewing the sources, here is the revised information on the components of an assembler:

1. **Header**: Contains metadata about the file, such as size and the location of various segments.
2. **Text Segment**: Contains the actual machine code instructions.
3. **Static Data Segment**: Holds global variables, constants, and static data.
4. **Relocation Information**: Identifies addresses that need to be updated when the program is loaded into memory.
5. **Symbol Table**: Stores information about symbols (labels and variables), including addresses for external references and unresolved references.
6. **Debugging Information**: Includes line number mappings and other data useful for debugging, linking the machine code back to the source code.

#### Java Program Translation

Here is an improved explanation of the Java program translation process with a diagram:

1. **Source Code Compilation**: The Java source code (`.java` files) is compiled into bytecode (`.class` files) by the Java compiler. These bytecode files are platform-independent and contain address references.
2. **Loading and Linking**: When a Java program is run, the Java Virtual Machine (JVM) loads the necessary `.class` files and links them. The JVM resolves the references to libraries and other classes as needed during this process.
3. **Just-In-Time (JIT) Compilation**: For improved performance, the JVM uses a Just-In-Time (JIT) compiler. The JIT compiler identifies "hot" methods that are frequently executed and compiles them into native machine code. This native code is then cached for future use, which reduces the overhead of interpretation.

![Java Program Translation](https://static.javatpoint.com/core/images/jit-in-java2.png)

<details>
<summary>
ü§î What is the advantage of an interpreter over a translator when designing Java?
</summary>

**Answer**:

In C, the code is directly compiled into machine-specific code, making it non-portable across different platforms. The C program undergoes this sequence: `C program -> Compiler -> Machine code -> Machine (Compilation or Translation)`.

In Java, the code is first compiled into platform-independent bytecode, which can then be executed on any machine with a Java Virtual Machine (JVM). This process is: `Java program -> Compiler -> Java bytecode -> JVM + JIT -> Machine (Interpretation)`. 

The key advantage of this approach is **portability**. Java bytecode can run on any platform with a JVM, making Java applications platform-independent. Additionally, the JVM can optimize the code at runtime using Just-In-Time (JIT) compilation, enhancing performance.
</details>

The table provided for the arithmetic instructions is mostly correct, but there are a few inaccuracies and clarifications needed. Here is a revised version of the table:

### Arithmetic Instructions
Perform binary operations. All instructions follow the format `op dest, src1, src2`, where `op` is the operation, `dest` is the destination register, and `src1` and `src2` are the source registers. Immediate and unsigned operations have similar formats with slight variations.

| Operation       | Format              | Function           | Example (C to MIPS)         |
|-----------------|---------------------|--------------------|-----------------------------|
| **Addition**    | `add $d, $s, $t`    | `$d <- $s + $t`      | `p = x + y` -> `add $s0, $s1, $s2` |
| **Subtraction** | `sub $d, $s, $t`    | `$d <- $s - $t`      | `p = x - y` -> `sub $s0, $s1, $s2` |
| **Addition Immediate** | `addi $d, $s, imm` | `$d <- $s + imm` | `p = x + 5` -> `addi $s0, $s1, 5` |
| **Unsigned Addition** | `addu $d, $s, $t` | `$d <- $s + $t` (unsigned) | `p = x + y` -> `addu $s0, $s1, $s2` |
| **Unsigned Subtraction** | `subu $d, $s, $t` | `$d <- $s - $t` (unsigned) | `p = x - y` -> `subu $s0, $s1, $s2` |
| **Unsigned Addition Immediate** | `addiu $d, $s, imm` |` $d <- $s + imm` (unsigned) | `p = x + 5` -> `addiu $s0, $s1, 5` |
| **Multiplication** | `mult $s, $t` | `Lo, Hi <- $s * $t`  | `mult $s1, $s2` (x * y -> Lo, Hi) |
| **Multiplication with Overflow** | `mul $d, $s, $t` |` $d <- $s * $t` (with overflow check) | `mul $s0, $s1, $s2` (x * y -> $s0) |
| **Division** | `div $s, $t` | `Lo <- $s / $t, Hi <- $s % $t` | `div $s1, $s2` (x / y -> Lo, x % y -> Hi) |




**Example**:
- C code: `a = b + c + d; e = f - a;`
- MIPS assembly:
    - `add $t0, $s1, $s2` (b + c -> \$t0)
    - `add $t0, $t0, $s3` (b + c + d -> \$t0)
    - `sub $s4, $s5, $t0` (f - (b + c + d) -> \$s4)

**Steps in Arithmetic Instruction Execution**:

1. **Register Assignment**: The compiler assigns registers to variables.
2. **Translation**: Convert high-level language statements to assembly instructions.
3. **Optimization**: The compiler optimizes the instructions for performance.

![Arithmetic Instruction](/co/add.png)

### Data Transfer Instructions
Move data between memory and registers. The format is `op dest, src`, where `op` is the operation, `dest` is the destination register, and `src` is the source register or memory address.

| Operation       | Format              | Function           | Example (C to MIPS)         |
|-----------------|---------------------|--------------------|-----------------------------|
| **Load Word**   | `lw $t, offset($s)` | `$t <- Mem[$s + offset]` | `p = A[i]` -> `lw $s0, i($s1)` |
| **Store Word**  | `sw $t, offset($s)` | `Mem[$s + offset] <- $t` | `A[i] = p` -> `sw $s0, i($s1)` |
| **Load Immediate** | `li $t, imm`     | `$t <- imm`        | `p = 5` -> `li $s0, 5` |
| **Load Address** | `la $t, label`    | `$t <- &label`     | `p = &A` -> `la $s0, A` |
| **Move**        | `move $d, $s`      | `$d <- $s`         | `p = q` -> `move $s0, $s1` |
| **Load Byte**   | `lb $t, offset($s)` | `$t <- Mem[$s + offset]` (byte) | `p = A[i]` -> `lb $s0, i($s1)` |
| **Store Byte**  | `sb $t, offset($s)` | `Mem[$s + offset] <- $t` (byte) | `A[i] = p` -> `sb $s0, i($s1)` |

**Example**:
- C code: `A[12] = h + A[8];` ($s1 holds the base address of A, $s2 holds h)
- MIPS assembly:
    - `lw $t0, 32($s1)` (Load A[8] -> \$t0)
    - `add $t0, $s2, $t0` (h + A[8] -> \$t0)
    - `sw $t0, 48($s1)` (Store h + A[8] -> A[12])


![Load Word Instruction](/co/lw.png)

![Store Word Instruction](/co/sw.png)


### Flow Control Instructions
Control the flow of execution based on conditions. The format is `op src1, src2, label`, where `op` is the operation, `src1` and `src2` are source registers, and `label` is the target label.

| Operation       | Format              | Function           | Example (C to MIPS)         |
|-----------------|---------------------|--------------------|-----------------------------|
| **Branch Equal** | `beq $s, $t, label` | Branch to label if `$s = $t` | `if (x == y) goto L` -> `beq $s0, $s1, L` |
| **Branch Not Equal** | `bne $s, $t, label` | Branch to label if `$s != $t` | `if (x != y) goto L` -> `bne $s0, $s1, L` |
| **Jump** | `j label` | Jump to label | `goto L` -> `j L` |

**Example - If-Else Statement**:
- C code: `if (x == y) z = 1; else z = 0;`
- MIPS assembly:
    - `beq $s0, $s1, L1` (Branch to L1 if x == y)
    - `li $s2, 0` (z = 0)
    - `j L2` (Jump to L2)
    - `L1: li $s2, 1` (z = 1)
    - `L2: ...`

**Example - Loop**:
- C code: `for (i = 0; i < 10; i++) sum += A[i];`
- MIPS assembly:
    - `li $s0, 0` (i = 0)
    - `li $s1, 10` (Upper bound)
    - `li $s2, 0` (sum = 0)
    - `Loop: beq $s0, $s1, Exit` (Check loop condition)
    - `lw $t0, 4($s0)` (Load A[i] -> \$t0)
    - `add $s2, $s2, $t0` (sum += A[i])
    - `addi $s0, $s0, 1` (Increment i)
    - `j Loop` (Jump back to Loop)
    - `Exit: ...`

#### Basic Blocks

A basic block is a sequence of instructions with a single entry point and a single exit point, containing no branches except at the end, and no branch targets except at the beginning. When the compiler translates high-level code to assembly, it identifies basic blocks to optimize execution block by block.

MIPS does not provide `blt`, `bgt`, `ble`, and `bge` instructions. Instead, these comparisons are achieved by combining `beq`, `bne`, and `slt` (Set on Less Than) instructions to produce **Pseudo-Instructions or Directive Instructions**. Here is the mapping:

| High-Level Comparison | MIPS Pseudo-Instruction | Equivalent MIPS Instructions                      |
|-----------------------|-------------------------|---------------------------------------------------|
| `if (x < y)`          | `blt $s0, $s1, label`   | `slt $t0, $s0, $s1` <br/> `bne $t0, $zero, label`  |
| `if (x > y)`          | `bgt $s0, $s1, label`   | `slt $t0, $s1, $s0` <br/> `bne $t0, $zero, label`  |
| `if (x <= y)`         | `ble $s0, $s1, label`   | `slt $t0, $s1, $s0` <br/> `beq $t0, $zero, label`  |
| `if (x >= y)`         | `bge $s0, $s1, label`   | `slt $t0, $s0, $s1` <br/> `beq $t0, $zero, label`  |

**Explanation**:
- **`slt $t0, $s0, $s1`**: Sets `$t0` to 1 if `$s0 < $s1`, otherwise sets `$t0` to 0.
- **`bne $t0, $zero, label`**: Branches to `label` if `$t0` is not equal to 0.
- **`beq $t0, $zero, label`**: Branches to `label` if `$t0` is equal to 0.

<details>
<summary>
üîç Deep Dive: Pseudo-Instructions
</summary>

**Pseudo-Instructions in MIPS**
MIPS does not provide some instructions directly, so we use pseudo-instructions to achieve the desired functionality. Here are some common pseudo-instructions and their equivalents in MIPS assembly:

| Pseudo-instruction | What it Accomplishes | Solution                     |
|--------------------|-----------------------|------------------------------|
| `move $t1, $t2`    | $t1 = $t2             | `add $t1, $t2, $zero`        |
| `clear $t0`        | $t0 = 0               | `add $t0, $zero, $zero`      |
| `beq $t1, small, L`| if ($t1 == small) go to L | `addi $at, $zero, small` <br/> `beq $t1, $at, L` |
| `beq $t2, big, L`  | if ($t2 == big) go to L | `lui $at, upper(big)` <br/> `ori $at, $at, lower(big)` <br/> `beq $t2, $at, L` |
| `li $t1, small`    | $t1 = small           | `addi $t1, $zero, small`     |
| `li $t2, big`      | $t2 = big             | `lui $t2, upper(big)` <br/> `ori $t2, $t2, lower(big)` |
| `addi $t5, big`    | $t5 = $t2 + big       | `lui $at, upper(big)` <br/> `ori $at, $at, lower(big)` <br/> `add $t5, $t2, $at` |
| `lw $t5, big($t2)` | $t5 = Memory[$t2 + big] | `lui $at, upper(big)` <br/> `ori $at, $at, lower(big)` <br/> `add $at, $t2, $at` <br/> `lw $t5, 0($at)` |

**Conditional Branching with Pseudo-Instructions**

MIPS lacks specific conditional instructions like `ble`, `bgt`, `blt`, and `bge`, so we use pseudo-instructions:

| Pseudo-instruction | What it Accomplishes | Solution                     |
|--------------------|-----------------------|------------------------------|
| `ble $t3, $t5, L`  | if ($t3 <= $t5) go to L | `slt $at, $t5, $t3` <br/> `beq $at, $zero, L` |
| `bgt $t4, $t5, L`  | if ($t4 > $t5) go to L | `slt $at, $t5, $t4` <br/> `bne $at, $zero, L` |
| `bge $t5, $t3, L`  | if ($t5 >= $t3) go to L | `slt $at, $t3, $t5` <br/> `beq $at, $zero, L` |

Addressing Immediate Values

The terms **small** and **big** refer to the size of the immediate value:
- **Small**: Fits within 16 bits, can be used directly.
- **Big**: Requires more than 16 bits, split into upper and lower parts using `lui` and `ori`.

- **Example**:
    - **Small** immediate: `addi $t1, $zero, 15`
    - **Big** immediate: `lui $t2, 0x1234` followed by `ori $t2, $t2, 0x5678` (to load 0x12345678 into $t2).

</details>

### Logical Instructions
